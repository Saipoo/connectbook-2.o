import mongoose from 'mongoose';

const confessionResponseSchema = new mongoose.Schema({
  from: {
    type: String,
    enum: ['Teacher', 'Admin', 'Counselor', 'AI'],
    required: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    refPath: 'responses.userModel'
  },
  userModel: {
    type: String,
    enum: ['Teacher', 'Admin']
  },
  message: {
    type: String,
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  isPrivate: {
    type: Boolean,
    default: false
  }
}, { _id: true });

const studentConfessionSchema = new mongoose.Schema({
  confessionId: {
    type: String,
    unique: true
    // Note: Will be auto-generated by pre-save hook
  },
  studentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Student',
    required: true
  },
  studentName: {
    type: String
  },
  studentUSN: {
    type: String
  },
  category: {
    type: String,
    enum: [
      'Academic Issue',
      'Faculty Concern',
      'Peer Conflict',
      'Personal/Emotional Concern',
      'College Infrastructure',
      'Harassment/Disciplinary Issue',
      'Other'
    ],
    required: true
  },
  subcategory: {
    type: String
  },
  // Encrypted content
  content: {
    type: String,
    required: true
  },
  // Original content hash for integrity verification
  contentHash: {
    type: String
  },
  visibility: {
    type: String,
    enum: ['Anonymous', 'Identified'],
    default: 'Anonymous'
  },
  status: {
    type: String,
    enum: ['Pending', 'Acknowledged', 'In Discussion', 'Resolved', 'Escalated'],
    default: 'Pending'
  },
  // AI-generated insights
  sentiment: {
    type: String,
    enum: ['Neutral', 'Sadness', 'Anger', 'Stress', 'Anxiety', 'Fear', 'Frustration', 'Hope', 'Gratitude']
  },
  sentimentScore: {
    type: Number,
    min: 0,
    max: 1
  },
  severity: {
    type: String,
    enum: ['Low', 'Medium', 'High', 'Critical'],
    default: 'Low'
  },
  severityScore: {
    type: Number,
    min: 0,
    max: 10
  },
  // AI-generated summary
  aiSummary: {
    type: String
  },
  aiRecommendation: {
    type: String
  },
  // Assignment
  assignedTo: [{
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Teacher'
    },
    role: {
      type: String,
      enum: ['Teacher', 'Counselor', 'Admin']
    },
    assignedAt: {
      type: Date,
      default: Date.now
    },
    assignedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Admin'
    }
  }],
  // Parent visibility
  shareWithParent: {
    type: Boolean,
    default: false
  },
  parentNotified: {
    type: Boolean,
    default: false
  },
  // Responses and updates
  responses: [confessionResponseSchema],
  // Admin notes (private)
  adminNotes: [{
    note: String,
    addedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Admin'
    },
    timestamp: {
      type: Date,
      default: Date.now
    }
  }],
  // Flags and priorities
  isFlagged: {
    type: Boolean,
    default: false
  },
  flaggedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Teacher'
  },
  flagReason: {
    type: String
  },
  priority: {
    type: String,
    enum: ['Normal', 'High', 'Urgent'],
    default: 'Normal'
  },
  // Timestamps
  submittedAt: {
    type: Date,
    default: Date.now
  },
  acknowledgedAt: {
    type: Date
  },
  resolvedAt: {
    type: Date
  },
  lastUpdated: {
    type: Date,
    default: Date.now
  },
  // Metadata
  isActive: {
    type: Boolean,
    default: true
  },
  isDeleted: {
    type: Boolean,
    default: false
  },
  viewCount: {
    type: Number,
    default: 0
  },
  // Voice recording metadata
  hasVoiceRecording: {
    type: Boolean,
    default: false
  },
  voiceRecordingUrl: {
    type: String
  },
  voiceRecordingDuration: {
    type: Number // in seconds
  }
}, {
  timestamps: true
});

// Indexes for efficient querying
studentConfessionSchema.index({ confessionId: 1 });
studentConfessionSchema.index({ studentId: 1 });
studentConfessionSchema.index({ status: 1 });
studentConfessionSchema.index({ category: 1 });
studentConfessionSchema.index({ severity: 1 });
studentConfessionSchema.index({ visibility: 1 });
studentConfessionSchema.index({ submittedAt: -1 });
studentConfessionSchema.index({ 'assignedTo.userId': 1 });

// Generate unique confession ID
studentConfessionSchema.pre('save', async function(next) {
  if (!this.confessionId) {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    this.confessionId = `CONF-${year}${month}-${random}`;
  }
  
  this.lastUpdated = new Date();
  next();
});

// Update timestamps based on status
studentConfessionSchema.pre('save', function(next) {
  if (this.isModified('status')) {
    if (this.status === 'Acknowledged' && !this.acknowledgedAt) {
      this.acknowledgedAt = new Date();
    }
    if (this.status === 'Resolved' && !this.resolvedAt) {
      this.resolvedAt = new Date();
    }
  }
  next();
});

// Static method to get confessions by role
studentConfessionSchema.statics.getByRole = async function(userId, userRole, filters = {}) {
  let query = { isActive: true, isDeleted: false };
  
  // Role-based filtering
  if (userRole === 'student') {
    query.studentId = userId;
  } else if (userRole === 'teacher') {
    // Teachers see:
    // 1. Confessions assigned to them
    // 2. All "Identified" (non-anonymous) confessions
    query.$or = [
      { 'assignedTo.userId': userId },
      { visibility: 'Identified' }
    ];
  } else if (userRole === 'parent') {
    // Get student ID for this parent by USN
    const Parent = mongoose.model('Parent');
    const Student = mongoose.model('Student');
    const parentUser = await Parent.findById(userId);
    if (parentUser && parentUser.linkedStudentUSN) {
      const student = await Student.findOne({ usn: parentUser.linkedStudentUSN });
      if (student) {
        query.studentId = student._id;
        query.shareWithParent = true;
      } else {
        // No student found - return empty result
        query._id = null;
      }
    } else {
      // No linked student - return empty result
      query._id = null;
    }
  }
  // Admin sees everything (no additional filter)
  
  // Apply additional filters
  if (filters.category) query.category = filters.category;
  if (filters.status) query.status = filters.status;
  if (filters.severity) query.severity = filters.severity;
  if (filters.visibility) query.visibility = filters.visibility;
  if (filters.isFlagged !== undefined) query.isFlagged = filters.isFlagged;
  
  return this.find(query)
    .populate('studentId', 'name email usn')
    .populate('assignedTo.userId', 'name email')
    .populate('assignedTo.assignedBy', 'name')
    .populate('flaggedBy', 'name')
    .populate('adminNotes.addedBy', 'name')
    .sort({ submittedAt: -1 });
};

// Instance method to add response
studentConfessionSchema.methods.addResponse = function(responseData) {
  this.responses.push(responseData);
  this.lastUpdated = new Date();
  return this.save();
};

// Instance method to add admin note
studentConfessionSchema.methods.addAdminNote = function(note, adminId) {
  this.adminNotes.push({
    note,
    addedBy: adminId,
    timestamp: new Date()
  });
  this.lastUpdated = new Date();
  return this.save();
};

// Instance method to assign to teacher/counselor
studentConfessionSchema.methods.assignTo = function(userId, role, assignedBy) {
  const existing = this.assignedTo.find(a => a.userId.toString() === userId.toString());
  if (!existing) {
    this.assignedTo.push({
      userId,
      role,
      assignedBy,
      assignedAt: new Date()
    });
    this.lastUpdated = new Date();
  }
  return this.save();
};

// Virtual for anonymized data
studentConfessionSchema.virtual('anonymizedData').get(function() {
  if (this.visibility === 'Anonymous') {
    const obj = this.toObject({ virtuals: false }); // Prevent circular reference
    return {
      ...obj,
      studentName: 'Anonymous',
      studentUSN: '****',
      studentId: null
    };
  }
  return this.toObject({ virtuals: false });
});

// Ensure virtuals are included in JSON (but not in toObject to prevent circular reference)
studentConfessionSchema.set('toJSON', { virtuals: false });
studentConfessionSchema.set('toObject', { virtuals: false });

const StudentConfession = mongoose.model('StudentConfession', studentConfessionSchema);
export default StudentConfession;
